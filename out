
mlfile :: fold.ml
specfile :: concat.specHIrelation Rhd (cons(x,xs)) = {(x)} | nil = {()};
relation Rmem = Rhd*;
relation Rob (cons(x,xs)) = {(x)} X Rmem(xs) | nil = {()};
relation Robs = Rob*;

concat : l1 -> l2 -> { l | Rmem(l) = Rmem(l1) U Rmem(l2)};

The lexeme 
*****Lexeme ends *********relationwhitespace var: Rhd
whitespace lparen
var: cons
lparen
var: x
comma
var: xs
rparen
rparen
whitespace equalopwhitespace lcurly
lparen
var: x
rparen
rcurly
whitespace pipe
whitespace var: nil
whitespace equalopwhitespace lcurly
lparen
rparen
rcurly
semicolon
relationwhitespace var: Rmem
whitespace equalopwhitespace var: Rhd
star
semicolon
relationwhitespace var: Rob
whitespace lparen
var: cons
lparen
var: x
comma
var: xs
rparen
rparen
whitespace equalopwhitespace lcurly
lparen
var: x
rparen
rcurly
whitespace crossprdwhitespace var: Rmem
lparen
var: xs
rparen
whitespace pipe
whitespace var: nil
whitespace equalopwhitespace lcurly
lparen
rparen
rcurly
semicolon
relationwhitespace var: Robs
whitespace equalopwhitespace var: Rob
star
semicolon
var: concat
whitespace colon
whitespace var: l1
whitespace arrow
whitespace var: l2
whitespace arrow
whitespace lcurly
whitespace var: l
whitespace pipe
whitespace var: Rmem
lparen
var: l
rparen
whitespace equalopwhitespace var: Rmem
lparen
var: l1
rparen
whitespace unionwhitespace var: Rmem
lparen
var: l2
rparen
rcurly
semicolon
case 4case 4case 2typespec case &&&&&&&&spec***********concat :  : : {l1:<?> |  true } -> : {l2:<?> |  true } -> {l:<?> |  (Rmem)(l) = ((Rmem)(l1) U (Rmem)(l2)) }   :   :relation (Rhd) = {::::xxs => {(x)}[] => {()}}
relation (Rmem) = {::: => (Rhd)*}
relation (Rob) = {::::xxs => ({(x)} X (Rmem)(xs))[] => {()}}
relation (Robs) = {::: => (Rob)*}
TyMod 1TyMod Pstr_value TyMod Pstr_value -2 TyCore tybidns  TyMod Pstr_value -3 Print the AST
found var 
fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
 	 found Tlink  	  ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a 	 
 arguments  ::   size   0 	 
 res  ::  
('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
found var 
f : 'a -> 'b -> 'a
 size   0 	 found Tlink  	  'a -> 'b -> 'a 	 
 arguments  ::   	 
 res  ::  'a ->
                                                                   'b -> 'a
found var 

accum : 'a
 size   0 	 found Tlink  	  'a 	 
 arguments  ::   	 
 res  ::  'a
found var 

l : 'b list
 size   0 	 found Tlink  	  'b list 	 
 arguments  ::   	 
 res  ::  'b listfound constructor 
const name []
'c listfound constructor 
const name ::'c->'c list->'c list
found var 

x : 'b
 size   0 	 found Tlink  	  'b 	 
 arguments  ::   	 
 res  ::  'b
found var 

xs : 'b list
Not a Tlink  
 
found var 
temp1 : 'a
 size   0
@Var Env Before:
[]

VB other
elabExpr case other
elabExpr case other
elabExpr case other
elabExpr Match again&&
elabExpr &&
elabExpr VB other
elabExpr 
@Var Env After:
[nil : .  .  {v_2:  'a list |  true }
:: : .  .  : : {x:'a |  true } : {xs:  'a list |  true } -> {v_1:  'a list |  true }
[] : .  .  {v_0:  'a list |  true }
]

@here3-4  
@here-elabRE-1  
@here-elabRE-2  
@here-elabRE-3  
@here3-5  
@here3-4  
@here-elabRE-1  
@here-elabRE-2  
@here-elabRE-3  
@here-elabRE-1  
@here-elabRE-2  
@here-elabRE-3  
@here-elabRE-1  
@here-elabRE-2  
@here-elabRE-3  
doItRInstApp-1RmemdoItRInstApp-2  'a list  'a list
  'a list
: @ss: :.   'a list :-> {TupleSort 'a}_______10@PTSInst1@here3-5  

@RE Elab RE :

 Rhd  ::  {type = : @ss: :.   'a list :-> {TupleSort 'a}; map = {::::xxs => {(x)}[] => {()}}} 
   
 Rmem  ::  {type = : @ss: :.   'a list :-> {TupleSort 'a}; map = {::::xxs => ({(x)} U ({()} U (Rmem)(xs)))[] => {()}}} 
   
 Rob  ::  {type = : @ss: :.   'a list :-> {TupleSort 'a'a}; map = {::::xxs => ({(x)} X (Rmem :'a)(xs))[] => {()}}} 
   
 Robs  ::  {type = : @ss: :.   'a list :-> {TupleSort 'a'a}; map = {::::xxs => (({(x)} X (Rmem :'a)(xs)) U ({()} U (Robs)(xs)))[] => {()}}} 

@PRE Elab PRE:

 Rhd  ::  {typescheme = : @ss: :.   'a list :-> {TupleSort 'a}, def = \v_1. bind (Rhd : (v_1),\:v_0. {(v_0)})} 
   
 Rmem  ::  {typescheme = : @ss: :.   'a list :-> {TupleSort 'a}, def = \v_3. bind (Rmem : (v_3),\:v_2. {(v_2)})} 
   
 Rob  ::  {typescheme = : @ss: :.   'a list :-> {TupleSort 'a'a}, def = \v_6. bind (Rob : (v_6),\:v_4v_5. ({(v_4)} X {(v_5)}))} 
   
 Robs  ::  {typescheme = : @ss: :.   'a list :-> {TupleSort 'a'a}, def = \v_9. bind (Robs : (v_9),\:v_7v_8. ({(v_7)} X {(v_8)}))} 
 ParamRefTy : {l1:<?> |  true } -> : {l2:<?> |  true } -> {l:<?> |  (Rmem)(l) = ((Rmem)(l1) U (Rmem)(l2)) }
@PROTO VE:
[concat : .  .  : {l1:<?> |  true } -> : {l2:<?> |  true } -> {l:<?> |  (Rmem)(l) = ((Rmem)(l1) U (Rmem)(l2)) }
]elaborating_possible_fun_exp 	 found Tlink  	  'a 	 
 arguments  ::   	 
 res  ::  'a